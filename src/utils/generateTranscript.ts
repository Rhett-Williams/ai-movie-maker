import OpenAI from "openai";

const client = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

export type GenerateTranscriptProps = {
  prompt: string;
  /** in minutes */
  duration: number;
};

export type Scene = {
  prompt: string;
  duration: number;
  location: string;
};

export type Characters = {
  name: string;
  description: string;
};

export type Movie = {
  title: string;
  transcript: Scene[];
  backgroundMusic: string;
  artStyle: string;
  characters: Characters[];
};

/**
 * Generate a sequence of movie scenes.
 * @param {string} prompt - The input movie idea.
 * @param {number} duration - The movie length in minutes.
 * @returns {Promise<Scene[]>} - An array of scene objects.
 */
export default async function generateTranscript({
  prompt,
  duration,
}: GenerateTranscriptProps): Promise<Movie> {
  console.log("Generating movie script");

  const response = await client.chat.completions.parse({
    model: "gpt-4o",
    messages: [
      {
        role: "system",
        content: `You are a screenplay assistant.

        You are writing a short film which will be generated by many separate AI text to video generations.

        This means that each video will not have context of the last.

        To keep the film looking seemless and continuous, descriptions of things cannot be ambiguous.

        This is because if a description can be interpreted in multiple ways, it will be different from scene to scene.

        Descriptions like "beautiful" or "floral" are not helpful.
        
        Each item in a scene must have a colour at the very least so it can be consistent across scenes.
      `,
      },
      {
        role: "system",
        content: `
  You are a screenplay assistant. Follow these rules precisely:
  
  1. Generate a short movie broken into standalone 8-second scenes. Each scene must be self-contained and describe the visuals, actions, and any dialogue.
  2. Avoid any provocative, offensive, or explicit content.
  3. Always return **strictly valid JSON** in this exact format:
  
  {
    "title": string,               // A creative, catchy movie title
    "backgroundMusic": string,     // Description of the background music; can include style or mood progression
    "artStyle": string,            // Visual style description (e.g., "cartoon", "Christopher Nolan", "retro")
    "characters": [                // characters can be an empty array, some short films wont have a character, such as an infomercial. A character can be a voice though. eg: { "name": "Narrator", "description": "Professional male voice, clear and enthusiastic tone" }
      {
        "name": string,            // Character name
        "description": string      // A fixed, unambiguous reference-style description.
                                   // Must specify exact details for clothing, colors, and distinctive features.
                                   // Do not use vague adjectives (e.g., "stylish", "small", "floral").
                                   // Instead, describe in a deterministic way (e.g., "round red glasses with thin gold rims", "hat with three blue daisies stitched into the left side").
                                   // This description is canonical and must remain consistent across all scenes.
      }
    ],
    "transcript": [
      {
        "prompt": string,          // Full description of a single 8-second scene, including any sound affects or dialog
        "location": string,        // Location of the scene, if the scene has scene has elements which need to be consistent, be sure to describe them in detail.
        "duration": number         // Always 8
      }
    ]
  }
  
  4. Ensure all strings are concise but vivid, especially for visual and character descriptions.
  5. Maintain coherence across scenes but keep each scene independently understandable.
  `,
      },
      {
        role: "user",
        content: `
      Create a sequence of movie scenes for the idea: "${prompt}".  
      The movie should be ${duration} minutes long.  
      `,
      },
    ],
    response_format: {
      type: "json_schema",
      json_schema: {
        name: "script_response",
        strict: true,
        schema: {
          type: "object",
          properties: {
            title: {
              type: "string",
            },
            backgroundMusic: {
              type: "string",
            },
            artStyle: {
              type: "string",
            },
            characters: {
              type: "array",
              items: {
                type: "object",
                properties: {
                  name: { type: "string" },
                  description: { type: "string" },
                },
                required: ["name", "description"],
                additionalProperties: false,
              },
            },
            transcript: {
              type: "array",
              items: {
                type: "object",
                properties: {
                  prompt: { type: "string" },
                  duration: { type: "number" },
                  location: { type: "string" },
                },
                required: ["prompt", "duration", "location"],
                additionalProperties: false,
              },
            },
          },
          required: [
            "title",
            "transcript",
            "backgroundMusic",
            "artStyle",
            "characters",
          ],
          additionalProperties: false,
        },
      },
    },
  });

  // âœ… Correct: Access the already-parsed response
  if (response.choices[0]?.message.parsed) {
    return createStandaloneScenes({
      movieData: response.choices[0].message.parsed,
    });
  }

  // Handle parsing failure
  throw new Error("Failed to generate valid transcript");
}

function createStandaloneScenes({ movieData }: { movieData: Movie }): Movie {
  const { title, artStyle, backgroundMusic, characters, transcript } =
    movieData;

  // Build a lookup for quick consistent character re-descriptions
  const characterMap = {};
  characters.forEach((char) => {
    characterMap[char.name] = char.description;
  });

  // Generate standalone scenes
  const standaloneScenes = transcript.map((scene, index) => {
    // Reintroduce characters explicitly if mentioned in the prompt
    let description = scene.prompt;

    Object.keys(characterMap).forEach((fullName) => {
      const nameParts = fullName.split(/\s+/); // Split on whitespace

      // First, try to match the full name
      const fullNameRegex = new RegExp(
        `\\b${fullName.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")}(?:'s)?\\b`,
        "g"
      );
      if (fullNameRegex.test(description)) {
        description = description.replace(
          fullNameRegex,
          `${fullName} (${characterMap[fullName]})`
        );
        return; // Skip partial matching if full name was found
      }

      // If full name not found, try each name part
      nameParts.forEach((namePart) => {
        if (namePart.length > 1) {
          // Avoid single letters
          const partRegex = new RegExp(
            `\\b${namePart.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")}(?:'s)?\\b`,
            "g"
          );
          if (partRegex.test(description)) {
            description = description.replace(
              partRegex,
              `${namePart} (${characterMap[fullName]})`
            );
          }
        }
      });
    });

    // Wrap scene with style + music info
    return {
      duration: scene.duration,
      prompt: `${description}
      Location: ${scene.location}
      Visual style: ${artStyle}.`,
    };
  });

  return {
    title,
    artStyle,
    backgroundMusic,
    characters,
    transcript: standaloneScenes,
  };
}
